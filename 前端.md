1.清浮动
    .clearFix,
    .clearFix::before,
    .clearFix::after{
        content:"";
        display:block;
        clear:both;
        *zoom:1;
    }
2.单行文本溢出打点  多行文本目前只能height 和line-height做限制
    white-space:no-wrap;不许换行
    overflow:hidden;
    text-overflow:ellipsis;
3.背景图片处理
    background-size:cover/contain   cover会完全覆盖整个区域 会有部分多余的被截取出来；contain会以一边进行缩放 会有铺不满的情况
    background:#f40f40 url() no-repeat top center / 20px 20px; 
    background-position:50% 50%;这个点是中心点
4.网速不好 图片不能显示 文字显示
    white-space:no-wrap;
    text-indent:200px;
    overflow:hidden;
    或：
    height:0;
    padding-height:图片高度
    overflow:hidden;
5.主流游览器
    google webkit/blink
    fireFox Gecko
    IE trident
    safari webkit
    Opera presto
6.number string boolean undefined null
    1/0 Inifinity number
    0/0 NaN not a number
    undefined=undefined Inifinity=Inifinity NaN！=NaN
    undefined null 既不大于0也不小于0也不等于0
    a=1&&2 =>a=2      a=0&&2 =>a=0
    a=1||2 =>a=1      a=0||2 =>a=2
    Number(null) 0
    Number("123aaa") undefined  =>NaN Number能把不像数字的装成NaN
    parseInt("123aaa") =>123 只把像转换成数字的部分 转换成数字
    parseInt(132,8) 132是8进制，要转换成10进制

##布局
    两栏自适应布局 overflow:auto;
    <style>
        .left {
        width: 200px;
        height: 500px;
        float: left;
        background: #999;
        }
        .main {
        height: 800px;
        background: #aaa;
        overflow: auto;
        color: #fff;
        }
    </style>
    <body>
        <div class="left"></div>
        <div class="main">
            <h1>BFC 两栏布局</h1>
            <p>
            左侧块浮动到左边，但是因为是浮动块，右侧块高度一旦超过左侧块后文字就会出现在左侧的下方，因为没有块把它挡住。
            </p>
            <p>解决办法： 让右侧块变为BFC文字就不会横过去。因为BFC元素不与Float元素相重叠。</p>
        </div>
    </body>
    双飞翼和圣杯布局（双飞翼多了个中心标签包裹）（圣杯利用padding 会中间宽度<左侧宽度时会布局混乱）
    <style>
      .left,
      .right,
      .main {
        min-height: 200px;
      }
      .left {
        width: 200px;
        background-color: thistle;
      }
      .main {
        background: #999;
      }
      .right {
        width: 300px;
        background-color: violet;
      }
      /* 双飞翼布局重点 */
      .left,
      .main,
      .right {
        float: left;
      }
      .main {
        width: 100%;
      }
      .main-inner {
        margin-left: 200px;
        margin-right: 300px;
      }
      .left {
        margin-left: -100%;
      }
      .right {
        margin-left: -300px;
      }
    </style>
    <body>
        <div class="main"><div class="main-inner">中心区</div></div>
        <div class="left">left</div>
        <div class="right">right</div>
    </body>

    <style type="text/css">
      /*基本样式*/
      .left, .right, .main {
        min-height: 300px;
      }
      .left {
        width: 200px;
        background-color:thistle;
      }
      .main {
        background-color: #999;
      }
      .right {
        width: 300px;
        background-color: violet;
      }
      /* 圣杯布局关键代码 */
      .left, .main, .right {
        float: left;
        position: relative;
      }
      .main {
        width: 100%;
      }
      .container {
        padding-left: 200px;
        padding-right: 300px;
      }
      .left {
        margin-left: -100%;
        left: -200px;
      }
      .right {
        margin-left: -300px;
        right: -300px;
      }
    </style>
    <body>
        <div class="container">
        <div class="main">main</div>
        <div class="left">left</div>
        <div class="right">right</div>
        </div>
    </body>
    三栏flex和三栏 表格/网格 布局
    flex:（父元素display:flex;中间元素：flex:1）
    表格布局：（父元素display:table;width:100%;每个子元素：display:table-cell;中间不加宽度，左右加宽度）
    网格布局： 

#动画
一般动画用到的几个属性：
animation:name duration timing-function delay iteration-count direction
eg:
div{
    animation:run 1 linear 1 infinite/**无限次循环*/ alternate/**允许动画逆向执行*/;
    -webkit-animation:run 1 linear 1 infinite alternate;
}
@keyframes run{
    0%{
        background:green;
    }
    50%{
        background:yellow;
    }
    100%{
        background:red;
    }
}

其实这里主要介绍的是 timing-function 的steps(num,type)
1.它是一个阶跃性函数，就是说它没有中间渐变的过程，直接从一个状态变到另一个状态；
2.它的第一个参数 作用于每两个关键帧之间，把他分成num段；第二个参数每个阶段的起点或终点发生阶跃性变化
如：
@keyframes run{
    0%{
        width:0%;
    }
    50%{
        width:50%;
    }
    100%{
        width:100%;
    }
}
steps(2) 就是把没两个帧之间分成2段，变成
@keyframes run{
    0%{
        width:0%;
    }
    25%{
        width:25%;
    }
    50%{
        width:50%;
    }
    75%{
        width:75%;
    }
    100%{
        width:100%;
    }
}

第二个参数  默认是end
如：
div{
    animation:run 1 steps(1,start) 1 infinite/**无限次循环*/ alternate/**允许动画逆向执行*/;
    -webkit-animation:run 1 steps(1,start) 1 infinite alternate;
}
@keyframes run{
    0%{
        background:green;
    }
    50%{
        background:yellow;
    }
    100%{
        background:red;
    }
}
当位steps(1,end)时，就是不断的绿色 黄色 变化
当位steps(1,start)时，就是不断的黄色 红色 变化

start,end 2个参数都会选择性的跳过前后部分，start跳过0%，end跳过100%
step-start在变化过程中，都是以下一帧的显示效果来填充间隔动画，所以0% 到 50% 直接就显示了黄色yellow
step-end与上面相反，都是以上一帧的显示效果来填充间隔动画，所以0% 到 50% 直接就显示了红色red

##flex布局
    flex布局的几个属性
        容器的属性：
            flex-direction:row|row-reverse|column|column-reverse
            flex-wrap:nowrap|wrap|wrap-reverse
            flex-flow:flex-direction flex-wrap;
            justify-content:flex-start|flex-end|center|space-between|space-around
            align-items:flex-start|flex-end|center|baseline|stetch
            align-content:flex-start|flex-end|center|space-between|space-around|stretch
        item的属性：
            order:0|...
            flex-grow:0|...
            flex-shrink:1|...
            flex-basis:auto|...
            flex: 0 1 auto;
            align-self:可覆盖 align-items的属性






#node.js
## NodeJS 特点

 - 非阻塞式的异步I/O
   - Node.js中采用了非阻塞型I/O机制，因此在执行了访问文件的代码之后，Nodejs不会阻塞在那里等待文件获取完成，而是把这件事交给底层操作系统，使用回调函数的方式来处理异步的IO，立即转而执行其它的代码，
 - 事件轮询
   - Nodejs接收到的事件会放到事件队列中，而不是立即执行它，当NodeJS当前代码执行完后他会检查事件队列中是否有事件，如果有，他会取出来依次执行
 - 单线程
   - Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的
   - 优点：不会死锁、不用像多线程那样处处在意同步问题、没有线程切换带来的性能上的开销
   - 缺点：多核CPU需单独开子线程、错误会使得整个应用退出、大量计算会占用CPU从而无法调用异步I/O
 - 擅长I/O密集型
   - 主要体现在Node利用事件轮询的方式处理事件，而不是单开一个线程来为每一个请求服务
 - 不擅长CPU密集型业务
   - 由于Node单线程，如果长时间运行计算将导致CPU不能释放，使得后续I/O无法发起。（解决办法是分解大型运算为多个小任务，不阻塞I/O发起）


### global对象
与在浏览器端不同，浏览器端将希望全局访问的对象挂到window上，而nodejs则将希望全局访问的对象挂到global对象上

###path模块
path.normalize()规范化给定的path，解析".."和"."
path.normalize('/foo/bar//baz/as/..')=》返回/foo/bar/baz/as

path.join()
path.join('/foo','bar','baz/as','..')=》返回/foo/bar/baz/as

path.resolve()把相对路径解析为绝对路径
path.resolve('1','/2/3/','4') 如果当前的工作目录为 /root/su
=>返回 /root/su/1/2/3/4

###basename dirname extname
basename   文件名.拓展名
dirname    所在的文件夹
extname    拓展名
```
┌─────────────────────┬────────────┐
│          dir        │    base    │
├──────┬              ├──────┬─────┤
│ root │              │ name │ ext │
"  /    home/user/dir / file  .txt "
└──────┴──────────────┴──────┴─────┘
```

###parse与format
--parse 是将字符串形式的文件路劲解析成一个包含 root dir base name ext属性的对象
--format 则是将这个对象代表的路径转换成字符串

```
js中
JSON.parse()
JSON.stringfy()返回字符串
php中
json_decode()
json_encode()返回字符串
```

###process模块
process.cwd() 获取当前执行的路径
process.argv 属性返回一个数组
 - 数组第一个元素为：node所安装的路径
 - 数组第二个元素为：当前执行文件的路径
 - 剩余元素为执行node命令时传入的参数
process.argv0
保存了process.argv数组的第一个值的*引用*，不常用


#### process.execArgv
process.execArgv 属性返回当Node.js进程被启动时，Node.js特定的命令行选项（位于node后，文件名之前）。 这些选项在process.argv属性返回的数组中不会出现。

#### process.execPath
返回启动 Node.js 进程的可执行文件的绝对路径名。基本就是 process.argv 的第一个参数

#### process.env
process.env 属性返回包含用户环境的对象。

CPU:处理器，类似商店里的营业员，单核一个人，双核2个人，四核4个人。。。。。
显卡：处理图像，类似商店外边的女模特，脸蛋好，长的越精致越贵。
内存：类似店铺营业间，越大摆放的商品越多。
硬盘：类似店铺的仓库，越大，摆放的越多。
硬盘和内存的区别，内存是商品展示（数据从硬盘搬到内存暂存），CPU（类似营业员）将内存的数据进行处理，如果缺数据了，就从硬盘搬到内存，顺手将内存暂时不用的数据搬回硬盘（仓库）。在硬盘（仓库）一个区域划出一块地方，用于暂时保存数据（暂时不用或即将要用的），这个区域就叫虚拟内存。影响显而易见。

####阿里百秀项目（博客管理系统）
第一个既有前台，又有后台的项目

####html5和css3
主要内容：动画和视频播放，历史，本地存储，拖拽，文件读取，网络，地理位置，离线缓存

####canva视频
主要内容：利用canvas画不同形状

####移动web视频
主要内容：移动算前端页面的编写

####电商项目
主要内容：m端和pc端，有后台接口文件（别人已经做好的），主要练习的是 前台页面的编写和与后端接口的适配

####node


####VUE



####rect


####果果点餐系统
####ajax音乐播放器
####微信公众号开发

####ajax异步通信
简单来说，就是 XMLHttpRequest对象与服务器之间进行通信，可以用json,html,text等文本格式发送和接受数据。ajax 最吸引人的就是他的 “异步”特性，也就是说，它可以在不重新刷新页面的情况下与服务器通信。

创建一个XMLHttpRequest对象
```
	//创建一个XMLHttpRequest对象
    if(window.XMLHttpRequest){//Mozilla,Safari,IE7+
		httpRequest=new XMLHttpRequest();
	}else{//IE6 and older
		httpRequest=new ActiveXObject('Microsoft.XMLHTTP')
	}
	//绑定onreadystatechange事件
	onreadystatechange=function(){
		//process the server response here .
	}
	//向服务器发送请求
	httpRequest.open('GET','http://www.example.org/some.file',true);
	httpRequest.send();

完整的例子：
function ajax(url,cb){
	let xhr;
 	if(window.XMLHttpRequest) {
    	xhr = new XMLHttpRequest();
  	} else {
    xhr = ActiveXObject("Microsoft.XMLHTTP");
  	}
  	xhr.onreadystatechange = function() {
    if(xhr.readyState == 4 && xhr.status == 200) {
     	cb(xhr.responseText);
    } 
  	}
  	xhr.open('GET', url, true);
  	xhr.send();
}

xhr.readyState的值
-0（未初始化）or(请求还未开始)
-1（正在加载）or(已经建立服务器连接)
-2（加载成功）or（请求已接受）
-3 (交互) or(正在处理请求)
-4（完成） or(请求已经完成，并且响应已经准备好)

访问服务端返回的数据
xhr.responseText服务端以文本字符的形式返回
xhr.responseXML以XMLDocument对象形式返回，之后可以使用js来处理

GET注意事项
如果不设置响应头‘Cache-Control:no-cache’游览器将会把响应缓存下来而且再也无法重新提交请求，当然也可总是提交不同的GET参数，比如时间戳或随机数

POST请求
需要设置RequestHeader 告诉后台 传递内容的编码方式 以及在send方法里面传入对应的值
xhr.open('POST',url,true)
xhr.setRequestHeader('Content-Type':'application/x-www-form-urlencode')
xhr.send('key1=value1&key2=value2')

ajax中的withCredentials
跨域请求是否提供凭据信息（cookie）,也可以简单理解为,当前请求为跨域请求时是否在请求中携带cookie
当为同源请求时，不管xhr.withCredentials为true/flase，效果都会相同，且会一直提供票据信息（cookie）
	var xhr = new XMLHttpRequest();
	xhr.open('GET', 'http://172.19.0.215:1314/learnLinkManager/getLearnLinkList', true);
	xhr.withCredentials = true;
	xhr.onreadystatechange = function() {
	  console.log('withCredentials=>', xhr.withCredentials);
	};
	xhr.send(null);

需要注意的是，当配置了xhr.withCredentials时，必须在后端增加response头信息Access-Control-Allow-Origin且必须指定域名，而不能指定为*。例如：
	res.setHeader('Access-Control-Allow-Origin','http://172.19.0.215:3333');
```

####cookie和session
cookie
服务器通过设置 set-cookie这个响应头，将cookie信息返回给游览器，游览器将响应头中的cookie保存在本地，当下次向服务器发送http请求时，游览器会自动将保存的这些cookie信息添加到请求头中。

session
存放在服务器的一种用来存放用户数据的类似HashTable的结构
游览器第一次发送请求时，服务器自动生成了HashTable和SessionID来唯一标识这个hash表，并将sessionID存放在cookie中,通过响应发送给游览器。游览器第二次发送请求时会将前一次服务器响应中的sessionID随着cookie发送到服务器上，服务器从请求中提取sessionID,并和之前保存的sessionID进行对比，找到这个用户对应的hash表

一般这个时间是有限制的，超时后销毁
当用户在应用程序的web页面间跳转是，存储的session对象不会丢失而是在整个用户会话中一直存在
session依赖于cookie,因为sessionID是存放在cookie中的


session与cookie的区别
--cookie在客户端，session在服务端
--cookie在客户端存放，容易伪造，不如session安全
--session会耗费大量服务器资源，cookie在每次HTTP请求中都会带上，影响网络性能
--域的支持范围不一样，比如：a.com的Cookie在a.com下都能用，而www.a.com的Session在api.a.com下都能使用

#### 常见状态码

##### 1XX 指示信息
表示请求已接收，继续处理

##### 2XX 成功
 - **200** OK
 - 204 No content，表示请求成功，但响应报文不含实体的主体部分
 - 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容
 - **206** Partial Content，进行范围请求

##### 3XX 重定向
 - **301** 永久性重定向，表示资源已被分配了新的 URL
 - **302** 临时性重定向，表示资源临时被分配了新的 URL
 - 303 表示资源存在着另一个 URL，应使用 GET 方法获取资源
 - **304** 未修改，重定位到浏览器。自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。
 - 307 临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求

##### 4XX 客户端错误
 - **404** 在服务器上没有找到请求的资源
 - **403** forbidden，表示对请求资源的访问被服务器拒绝
 - 400 请求报文存在语法错误
 - 401  表示发送的请求需要有通过 HTTP 认证的认证信息

##### 5XX 服务器错误
 - **500** 表示服务器端在执行请求时发生了错误
 - 501 表示服务器不支持当前请求所需要的某个功能
 - **503** 表明服务器暂时处于超负载或正在停机维护，无法处理请求

####https协议
https协议用到了对称加密和非对称加密 SSL/TLS
一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。

1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口
2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3. 服务器将自己的公钥发送给客户端。
4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。
5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7. 然后服务器将加密后的密文发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

原文链接：https://www.jianshu.com/p/14cd2c9d2cd2

####游览器中输入url到页面加载完成的过程
[参考链接](https://segmentfault.com/a/1190000006879700)

![输入URL后.png](../img/输入URL后.png)

 - 判断是否需要跳转(301)
 - 从浏览器中读取缓存
 - DNS解析
 - TCP连接
 - HTTP请求发出
 - 服务端处理请求，HTTP响应返回
 - 浏览器拿到响应数据，解析响应内内容，把解析结果展示给用户



1. 在浏览器地址栏输入URL
2. 浏览器查看是否有**强缓存**，如果请求资源在缓存中并且新鲜，跳转到转码步骤
    1. 如果资源未缓存，发起新请求
    2. 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
    3. 检验新鲜通常有两个HTTP头进行控制`Expires`和`Cache-Control`：
        - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
        - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
3. 浏览器**解析URL**获取协议，主机，端口，path
4. 浏览器**组装一个HTTP（GET）请求报文**
5. **DNS解析**，查找过程如下：
    1. 浏览器缓存
    2. 本机缓存
    3. hosts文件
    4. 路由器缓存
    5. ISP DNS缓存
    6. DNS查询（递归查询 / 迭代查询）
6. **端口建立TCP链接**，三次握手如下：
    1. 客户端发送一个TCP的**SYN=1，Seq=X**的包到服务器端口
    2. 服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包
    3. 客户端发送**ACK=Y+1， Seq=Z**
7. TCP链接建立后**发送HTTP请求**
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
9. 服务器检查**HTTP请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
11. 服务器将**响应报文通过TCP连接发送回浏览器**
12. 浏览器接收HTTP响应，然后根据情况选择**关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下**：
    1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文
    2. 被动方发送**ACK=X+1， Seq=Z**报文
    3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文
    4. 主动方发送**ACK=Y， Seq=X**报文
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
14. 如果资源可缓存，**进行缓存**
15. 对响应进行**解码**（例如gzip压缩）
16. 根据资源类型决定如何处理（假设资源为HTML文档）
17. **解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本**，这些操作没有严格的先后顺序，以下分别解释
18. **构建DOM树**：
    1. **Tokenizing**：根据HTML规范将字符流解析为标记
    2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
    3. **DOM construction**：根据HTML标记关系将对象组成DOM树
19. 解析过程中遇到图片、样式表、js文件，**启动下载**
20. 构建**CSSOM树**：
    1. **Tokenizing**：字符流转换为标记流
    2. **Node**：根据标记创建节点
    3. **CSSOM**：节点创建CSSOM树
21. **[根据DOM树和CSSOM树构建渲染树](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)**:
    1. 从DOM树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被css隐藏的节点，如`display: none`
    2. 对每一个可见节点，找到恰当的CSSOM规则并应用
    3. 发布可视节点的内容和计算样式
22. **js解析如下**：
    1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate为loading**
    2. HTML解析器遇到**没有async和defer的script时**，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。**同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容**
    3. 当解析器遇到设置了**async**属性的script时，开始下载脚本并继续解析文档。脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素
    4. 当文档完成解析，document.readState变成interactive
    5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用document.write()
    6. 浏览器**在Document对象上触发DOMContentLoaded事件**
    7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState变为complete,window触发load事件
23. **显示页面**（HTML解析过程中会逐步显示页面）



1.DNS解析
当你输入www.baidu.com时，其实不是百度网址真正上的地址。互联网上每一台计算机的唯一标识是IP地址，因为IP地址不方便记忆，所以才有了域名：www.baidu.com. 从网址到ip地址的一个转换过程，就是DNS解析。（就是充当了一个翻译的作用）
IP和域名之间的对应关系，全部储存在服务器中，每次输入www.baidu.com,都会查找其对应的IP地址，如何查找？
首先在本地域名服务器中查找IP地址，如果没有找到，本地域名服务器会向根域名服务器发送请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名发送一个请求，以此类推。。。直到最后，本地域名服务器得到baidu的IP地址并把它缓存到本地，供下次查询。
可以总结：网址的解析过程，从左到右：www.baidu.com->baidu.com->com。好像少了点什么？根域名服务器的解析过程呢？事实上，真正的网址是www.baidu.com.,注意这里多了一个点，这个点对应的就是根域名服务器，为了方便用户，通常会省略这个点，游览器在请求DNS时，所有网址的真正解析路劲为.->.com->baidu.com->www.baidu.com
在某个域名服务器中找到了对应的域名，则把返回的结果，保存至本地域名服务器中，备下次使用。

解析顺序

　　1） 浏览器缓存

　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；

　　2） 系统缓存

　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；

　　3） 路由器缓存

　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；

　　4） ISP（互联网服务提供商）DNS缓存

　　当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；

　　5） 根域名服务器

　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；

　　6） 顶级域名服务器

　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；

　　7） 主域名服务器

　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；

　　8）保存结果至缓存

　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。

### OSI 七层协议
 - 应用层
   - 为应用提供通信服务
 - 表示层
   - 定义数据格式以及加密
 - 会话层
   - 定义了如何开始、控制、结束一个会话，包括对多个双向消息的控制和管理。
 - 传输层
   - 选择差错恢复协议还是无差错恢复协议
   - TCP、UDP
 - 网络层
   - 端到端包传输。
   - 路由选择、包分解成更小的包
 - 数据链路层
   - 定义单个链路上如何传输数据
 - 物理层
   - 传输介质相关

####前端注意哪些seo
1.合理的title description keywords搜索对这三项的权重逐渐减小
2.语义化的html，符合W3C规范，可以让搜索引擎更容易理解
3.重要的html放在前面，搜索引擎抓取的顺序是从上到下，有的搜索引擎对抓取的长度有限制，要保证重要的内容一定被抓取
4.重要的内容不要用js输出，爬虫不会执行js获取内容
5.少用iframe,搜索引擎不会抓取iframe中的内容
6.非装饰性图片必须加alt
7.提高网站速度，网站速度是搜索引擎排序的一个重要指标


###node
####node安装，一般官网下载，安装，安装会自动安装npm,安装成功，在控制台 node -v,弹出版本号即可。

####用node执行文件，启动node.exe,切换到相关目录，执行node aa.js
进入文件夹，npm init 会有package.json/package-lock.json文件，这个文件的主要作用是 用到了什么包，会有记录，如果不小心删掉了package.json包，因为package-lock.json包的存在，直接npm install 就会直接把重新下载。

####node中 文件操作
fs=require('fs')
fs.readFile('file','utf8',function(err,data){

})

####node中mongodb数据库操作（非关系型数据库）下载mongodb 配置path
一般使用mongoose这个第三方包，来操作数据库

MongoDB将数据目录存储在 db 目录下。但是这个数据目录不会主动创建，我们在安装完成后需要创建它。请注意，数据目录应该放在根目录下，如我的mongodb安装在D盘，则在D盘新建data/db目录
1.打开mongodb数据库服务 输入mongod
2.连接mongodb数据库 输入mongo
3.show dbs展示所有的数据库
  db展示当前的数据库
  use test 进入test 数据库

npm install mongoose

    var mongoose=require('mongoose')
	连接数据库
	mongoose.connect("mongodb://localhost/test",{useMongoClient:true};
	
	创建一个模型
	mongoose.model("Cat",{name:string});
	
	实例化
	var kitty=new Cat({name:"kitty"})
	
	持久化保存一个实例
	kitty.save()
或者
find()
findById()
findByIdAndDelete()
findByIdAndRemove()
findByIdAndUpdate()
findOne()
findOneAndDelete()
findOneAndRemove()
findOneAndReplace()
findOneAndUpdate()
	var mongoose = require('mongoose')
	
	var Schema = mongoose.Schema
	
	// 1. 连接数据库
	// 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来
	mongoose.connect('mongodb://localhost/itcast')
	
	// 2. 设计文档结构（表结构）
	// 字段名称就是表结构中的属性名称
	// 约束的目的是为了保证数据的完整性，不要有脏数据
	var userSchema = new Schema({
	  username: {
	    type: String,
	    required: true // 必须有
	  },
	  password: {
	    type: String,
	    required: true
	  },
	  email: {
	    type: String
	  }
	})
	
	// 3. 将文档结构发布为模型
	//    mongoose.model 方法就是用来将一个架构发布为 model
	//    第一个参数：传入一个大写名词单数字符串用来表示你的数据库名称
	//                 mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称
	//                 例如这里的 User 最终会变为 users 集合名称
	//    第二个参数：架构 Schema
	//   
	//    返回值：模型构造函数
	var User = mongoose.model('User', userSchema)
	
	
	// 4. 当我们有了模型构造函数之后，就可以使用这个构造函数对 users 集合中的数据为所欲为了（增删改查）
	
	// var admin = new User({
	//   username: 'zs',
	//   password: '123456',
	//   email: 'admin@admin.com'
	// })
	
	// admin.save(function (err, ret) {
	//   if (err) {
	//     console.log('保存失败')
	//   } else {
	//     console.log('保存成功')
	//     console.log(ret)
	//   }
	// })
	
	// User.find(function (err, ret) {
	//   if (err) {
	//     console.log('查询失败')
	//   } else {
	//     console.log(ret)
	//   }
	// })
	
	// User.find({
	//   username: 'zs'
	// }, function (err, ret) {
	//   if (err) {
	//     console.log('查询失败')
	//   } else {
	//     console.log(ret)
	//   }
	// })
	
	// User.findOne({
	//   username: 'zs'
	// }, function (err, ret) {
	//   if (err) {
	//     console.log('查询失败')
	//   } else {
	//     console.log(ret)
	//   }
	// })

	// User.remove({
	//   username: 'zs'
	// }, function (err, ret) {
	//   if (err) {
	//     console.log('删除失败')
	//   } else {
	//     console.log('删除成功')
	//     console.log(ret)
	//   }
	// })
	
	
	// User.findByIdAndUpdate('5a001b23d219eb00c8581184', {
	//   password: '123'
	// }, function (err, ret) {
	//   if (err) {
	//     console.log('更新失败')
	//   } else {
	//     console.log('更新成功')
	//   }
	// })

mysql
	var mysql = require('mysql');
	
	// 1. 创建连接
	var connection = mysql.createConnection({
	  host: 'localhost',
	  user: 'root',
	  password: 'root',
	  database: 'users' // 对不起，我一不小心把数据库名字和表名起成一样的，你知道就行
	});
	
	// 2. 连接数据库 打开冰箱门
	connection.connect();
	
	// 3. 执行数据操作 把大象放到冰箱
	connection.query('SELECT * FROM `users`', function (error, results, fields) {
	  if (error) throw error;
	  console.log('The solution is: ', results);
	});
	
	// connection.query('INSERT INTO users VALUES(NULL, "admin", "123456")', function (error, results, fields) {
	//   if (error) throw error;
	//   console.log('The solution is: ', results);
	// });
	
	// 4. 关闭连接 关闭冰箱门
	connection.end();

####promise回调
层层嵌套，代码不好看，回调地狱，提出promise,jquery mongoose支持回调。
封装回调
	var fs = require('fs')
	
	function pReadFile(filePath) {
	  return new Promise(function (resolve, reject) {
	    fs.readFile(filePath, 'utf8', function (err, data) {
	      if (err) {
	        reject(err)
	      } else {
	        resolve(data)
	      }
	    })
	  })
	}
	
	pReadFile('./data/a.txt')
	  .then(function (data) {
	    console.log(data)
	    return pReadFile('./data/b.txt')
	  })
	  .then(function (data) {
	    console.log(data)
	    return pReadFile('./data/c.txt')
	  })
	  .then(function (data) {
	    console.log(data)
	  })

##VUE涉及知识点
###VUE的基本代码：
	<div id="app">{{msg}}</div>
	var vm=new Vue({
		ele:"#app",
		data:{
			msg:"welcome"
		}
	})
###v-cloak能够解决插值表达式闪烁的问题
	<p v-cloak>---{{msg}}---</p>
v-text是没有闪烁问题的
	<p v-text="msg"></p>
	<p v-html="msg"></p>
v-bind:用于绑定属性的指令 缩写：
	<input type="button" value="按钮" v-bind:title="msg1 + '123'">
v-on：事件绑定机制 缩写@
	<input type="button" value="按钮" :title="msg + '123'" v-on:click="alert('hello')"> -->
    <input type="button" value="按钮" @click="show">
	var vm=new Vue({
		ele:"#app",
		data:{
			msg:"welcome"
		},
	methods:{
		show：function(){alert("hello");}
	}
	})
###事件修饰符
```
$('#btn').click(function(e){e.stopPropagation()})
总结：
event.stopPropagation()阻止事件冒泡，但是不会阻止默认行为
return false阻止事件冒泡，也阻止默认行为
event.preventDefault()不阻止冒泡行为，但是阻止默认事件

###数组和对象的判断
arr instanceof Array //true
arr.constructor===Array //true
上述两种方法有缺陷：当你在多个frame之间来回穿梭时，每个frame都有自己的执行环境，跨实例化对象彼此是不共享原型链的，因此会导致上面两种方法都失效
Object.prototype.toString.call(arr)===[object Array]
Array.isArray() IE8以前不支持

###深拷贝函数封装
function deepClone(eleObj){
	var targetEle={}
	if(Object.prototype.toString.call(eleObj)==="[object Array]"){
		targetEle=[];
	}
	for(var item in eleObj){
		if(typeof(item)=="object"&&item!==null){
			deepClone(item)
		}
		targetEle[item]=eleObj[item];
	}
	return targetEle;
}



###prototype和__proto__
只有函数有prototype 属性
__proto__是对于对象的属性来说的。和作用域链行为类似，他会现在自己的对象中查找，查找不到，就会在__proto__中查找。

prototype属性指向prototype对象，prototype对象中又有一个constructor属性，这个属性同样指向一个constructor对象，而这个对象恰恰就是这个function函数本身

###继承的封装
function extend(subClass,superClass){
	var F=function(){}
	F.prototype=superClass.prototype
	subClass.prototype=new F()
	subClass.prototype.constructor=subClass

	subClass.superclass=superClass.prototype
}
###克隆的封装
function clone(object){
		function F(){}
		F.prototype=object
		return new F;
}

###call,apply,bind,箭头函数
box.onclick = function(){
　　function fn(){
　　　　alert(this);
　　}
　　fn();
};
我们原本以为这里面的this指向的是box,然而却是Window。一般我们这样解决：
box.onclick = function(){
　　var _this = this;
　　function fn(){
　　　　alert(_this);
　　}
　　fn();
};

box.onclick = function(){
　　function fn(){
　　　　console.log(this);
　　}
　　fn.call(this);
};

call(obj,1,2,3)
apply(obj,[1,2,3])
f=fn.bind(obj,1,2) f(3)
bind绑定好this之后，想什么时候执行就什么时候执行。而其他的会立即执行

箭头函数中this，指的是上一层的this

eval("2+3")可以将字符串处理成表达式进行执行
```
.stop阻止冒泡事件
	<div class="inner" @click="div1Handler">
      <input type="button" value="戳他" @click.stop="btnHandler">
    </div>
.prevent阻止默认行为
	<a href="http://www.baidu.com" @click.prevent="linkClick">有问题，先去百度</a>

.capture实现捕获机制的触发
	<div class="inner" @click.capture="div1Handler">
      <input type="button" value="戳他" @click="btnHandler">
    </div>
.self实现只有点击当前元素的时候，才会触发处理事件
.once只触发一次的事件处理函数
###v-model实现数据的双向绑定
<input type="text" style="width:100%;" v-model="msg">当input中的值发生改变时,msg中内容发生改变
####Vue中的class样式
	以前：<h1 class="red thin">这是一个很大很大的H1，大到你无法想象！！！</h1>
	<!-- 第一种使用方式，直接传递一个数组，注意： 这里的 class 需要使用  v-bind 做数据绑定 -->
    <!-- <h1 :class="['thin', 'italic']">这是一个很大很大的H1，大到你无法想象！！！</h1> -->

	<!-- 在数组中使用三元表达式 -->
    <!-- <h1 :class="['thin', 'italic', flag?'active':'']">这是一个很大很大的H1，大到你无法想象！！！</h1> -->

    <!-- 在数组中使用 对象来代替三元表达式，提高代码的可读性 -->
    <!-- <h1 :class="['thin', 'italic', {'active':flag} ]">这是一个很大很大的H1，大到你无法想象！！！</h1> -->

    <h1 :class="classObj">这是一个很大很大的H1，大到你无法想象！！！</h1>
###Vue中的style样式
	<!-- <h1 :style="styleObj1">这是一个h1</h1> -->

    <h1 :style="[ styleObj1, styleObj2 ]">这是一个h1</h1>
###v-for循环普通数组
	<div id="app">
	    <!-- <p>{{list[0]}}</p>
	    <p>{{list[1]}}</p>
	    <p>{{list[2]}}</p>
	    <p>{{list[3]}}</p>
	    <p>{{list[4]}}</p> -->
	
	    <p v-for="(item, i) in list">索引值：{{i}} --- 每一项：{{item}}</p>
	
	  </div>
	
	  <script>
	    // 创建 Vue 实例，得到 ViewModel
	    var vm = new Vue({
	      el: '#app',
	      data: {
	        list: [1, 2, 3, 4, 5, 6]
	      },
	      methods: {}
	    });
	  </script>
###v-for循环对象数组
	<div id="app">
	    <p v-for="(user, i) in list">Id：{{ user.id }} --- 名字：{{ user.name }} --- 索引：{{i}}</p>
	 </div>
###v-for循环对象
	<div id="app">
	    <!-- 注意：在遍历对象身上的键值对的时候， 除了 有  val  key  ,在第三个位置还有 一个 索引  -->
	    <p v-for="(val, key, i) in user">值是： {{ val }} --- 键是： {{key}} -- 索引： {{i}}</p>
	</div>
###v-for迭代数字
	<div id="app">
	    <!-- in 后面我们放过  普通数组，对象数组，对象， 还可以放数字 -->
	    <!-- 注意：如果使用 v-for 迭代数字的话，前面的 count 值从 1 开始 -->
	    <p v-for="count in 10">这是第 {{ count }} 次循环</p>
	 </div>
###v-for中key值的使用
	场景：每次添加一条信息时，若开始checkbox中勾选一条数据，添加数据后，选中的数据会变成不是原先那一条，
	<!-- 在组件中，使用v-for循环的时候，或者在一些特殊情况中，如果 v-for 有问题，必须 在使用 v-for 的同时，指定 唯一的 字符串/数字 类型 :key 值 -->
    <p v-for="item in list" :key="item.id">
      <input type="checkbox">{{item.id}} --- {{item.name}}
    </p>

###v-if和v-show的区别

----------------------------------------------------------
##品牌案例 Vue可以让我们免除dom操作

